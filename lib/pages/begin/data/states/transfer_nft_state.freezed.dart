// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'transfer_nft_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TransferNFTStateTearOff {
  const _$TransferNFTStateTearOff();

  TransferNFTInitial init() {
    return const TransferNFTInitial();
  }

  TransferNFTLoading loading() {
    return const TransferNFTLoading();
  }

  TransferNFTData data() {
    return const TransferNFTData();
  }

  TransferNFTError error({required String msg}) {
    return TransferNFTError(
      msg: msg,
    );
  }
}

/// @nodoc
const $TransferNFTState = _$TransferNFTStateTearOff();

/// @nodoc
mixin _$TransferNFTState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(String msg) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransferNFTInitial value) init,
    required TResult Function(TransferNFTLoading value) loading,
    required TResult Function(TransferNFTData value) data,
    required TResult Function(TransferNFTError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransferNFTStateCopyWith<$Res> {
  factory $TransferNFTStateCopyWith(
          TransferNFTState value, $Res Function(TransferNFTState) then) =
      _$TransferNFTStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$TransferNFTStateCopyWithImpl<$Res>
    implements $TransferNFTStateCopyWith<$Res> {
  _$TransferNFTStateCopyWithImpl(this._value, this._then);

  final TransferNFTState _value;
  // ignore: unused_field
  final $Res Function(TransferNFTState) _then;
}

/// @nodoc
abstract class $TransferNFTInitialCopyWith<$Res> {
  factory $TransferNFTInitialCopyWith(
          TransferNFTInitial value, $Res Function(TransferNFTInitial) then) =
      _$TransferNFTInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$TransferNFTInitialCopyWithImpl<$Res>
    extends _$TransferNFTStateCopyWithImpl<$Res>
    implements $TransferNFTInitialCopyWith<$Res> {
  _$TransferNFTInitialCopyWithImpl(
      TransferNFTInitial _value, $Res Function(TransferNFTInitial) _then)
      : super(_value, (v) => _then(v as TransferNFTInitial));

  @override
  TransferNFTInitial get _value => super._value as TransferNFTInitial;
}

/// @nodoc

class _$TransferNFTInitial implements TransferNFTInitial {
  const _$TransferNFTInitial();

  @override
  String toString() {
    return 'TransferNFTState.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is TransferNFTInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(String msg) error,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransferNFTInitial value) init,
    required TResult Function(TransferNFTLoading value) loading,
    required TResult Function(TransferNFTData value) data,
    required TResult Function(TransferNFTError value) error,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class TransferNFTInitial implements TransferNFTState {
  const factory TransferNFTInitial() = _$TransferNFTInitial;
}

/// @nodoc
abstract class $TransferNFTLoadingCopyWith<$Res> {
  factory $TransferNFTLoadingCopyWith(
          TransferNFTLoading value, $Res Function(TransferNFTLoading) then) =
      _$TransferNFTLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$TransferNFTLoadingCopyWithImpl<$Res>
    extends _$TransferNFTStateCopyWithImpl<$Res>
    implements $TransferNFTLoadingCopyWith<$Res> {
  _$TransferNFTLoadingCopyWithImpl(
      TransferNFTLoading _value, $Res Function(TransferNFTLoading) _then)
      : super(_value, (v) => _then(v as TransferNFTLoading));

  @override
  TransferNFTLoading get _value => super._value as TransferNFTLoading;
}

/// @nodoc

class _$TransferNFTLoading implements TransferNFTLoading {
  const _$TransferNFTLoading();

  @override
  String toString() {
    return 'TransferNFTState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is TransferNFTLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(String msg) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransferNFTInitial value) init,
    required TResult Function(TransferNFTLoading value) loading,
    required TResult Function(TransferNFTData value) data,
    required TResult Function(TransferNFTError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class TransferNFTLoading implements TransferNFTState {
  const factory TransferNFTLoading() = _$TransferNFTLoading;
}

/// @nodoc
abstract class $TransferNFTDataCopyWith<$Res> {
  factory $TransferNFTDataCopyWith(
          TransferNFTData value, $Res Function(TransferNFTData) then) =
      _$TransferNFTDataCopyWithImpl<$Res>;
}

/// @nodoc
class _$TransferNFTDataCopyWithImpl<$Res>
    extends _$TransferNFTStateCopyWithImpl<$Res>
    implements $TransferNFTDataCopyWith<$Res> {
  _$TransferNFTDataCopyWithImpl(
      TransferNFTData _value, $Res Function(TransferNFTData) _then)
      : super(_value, (v) => _then(v as TransferNFTData));

  @override
  TransferNFTData get _value => super._value as TransferNFTData;
}

/// @nodoc

class _$TransferNFTData implements TransferNFTData {
  const _$TransferNFTData();

  @override
  String toString() {
    return 'TransferNFTState.data()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is TransferNFTData);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(String msg) error,
  }) {
    return data();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
  }) {
    return data?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransferNFTInitial value) init,
    required TResult Function(TransferNFTLoading value) loading,
    required TResult Function(TransferNFTData value) data,
    required TResult Function(TransferNFTError value) error,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class TransferNFTData implements TransferNFTState {
  const factory TransferNFTData() = _$TransferNFTData;
}

/// @nodoc
abstract class $TransferNFTErrorCopyWith<$Res> {
  factory $TransferNFTErrorCopyWith(
          TransferNFTError value, $Res Function(TransferNFTError) then) =
      _$TransferNFTErrorCopyWithImpl<$Res>;
  $Res call({String msg});
}

/// @nodoc
class _$TransferNFTErrorCopyWithImpl<$Res>
    extends _$TransferNFTStateCopyWithImpl<$Res>
    implements $TransferNFTErrorCopyWith<$Res> {
  _$TransferNFTErrorCopyWithImpl(
      TransferNFTError _value, $Res Function(TransferNFTError) _then)
      : super(_value, (v) => _then(v as TransferNFTError));

  @override
  TransferNFTError get _value => super._value as TransferNFTError;

  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(TransferNFTError(
      msg: msg == freezed
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TransferNFTError implements TransferNFTError {
  const _$TransferNFTError({required this.msg});

  @override
  final String msg;

  @override
  String toString() {
    return 'TransferNFTState.error(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TransferNFTError &&
            const DeepCollectionEquality().equals(other.msg, msg));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(msg));

  @JsonKey(ignore: true)
  @override
  $TransferNFTErrorCopyWith<TransferNFTError> get copyWith =>
      _$TransferNFTErrorCopyWithImpl<TransferNFTError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loading,
    required TResult Function() data,
    required TResult Function(String msg) error,
  }) {
    return error(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
  }) {
    return error?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loading,
    TResult Function()? data,
    TResult Function(String msg)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TransferNFTInitial value) init,
    required TResult Function(TransferNFTLoading value) loading,
    required TResult Function(TransferNFTData value) data,
    required TResult Function(TransferNFTError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TransferNFTInitial value)? init,
    TResult Function(TransferNFTLoading value)? loading,
    TResult Function(TransferNFTData value)? data,
    TResult Function(TransferNFTError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class TransferNFTError implements TransferNFTState {
  const factory TransferNFTError({required String msg}) = _$TransferNFTError;

  String get msg;
  @JsonKey(ignore: true)
  $TransferNFTErrorCopyWith<TransferNFTError> get copyWith =>
      throw _privateConstructorUsedError;
}
